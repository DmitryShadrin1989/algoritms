package alex.a2;

/*
Это связано с тем, что в массиве a длины n только a[1],a[2], . . . ,a[n¡1] сравниваются с нашим maxSoFar
в операторе if. Обратите внимание, что a[0] не участвует в операторе if.
Вы можете использовать этот алгоритм для нахождения максимального значения и почти идентичный алгоритм для
нахождения минимального значения. Однако вам понадобится 2n ¡ 2 сравнения (n ¡ 1 для max и еще n ¡ 1 для
min). Здесь важны только сравнения между входными целыми числами (прямо или косвенно), вот почему
мы не учитываем сравнения, сделанные по i<a.length в приведенном выше примере. Ваша цель в этой задаче -
добиться большего!

который принимает массив целых чисел, находит минимум и максимум среди этих чисел
и возвращает среднее значение минимума и максимума (как показано в приведенном выше коде). Для полной оценки, если
входные данные содержат n чисел, ваша функция должна использовать менее 3n / 2 сравнений.
Затем: В качестве комментариев в вашем файле кода приведите логический аргумент в пользу того, почему ваш код действительно использует
меньше 3n / 2 сравнений.
(Подсказка: Помните задачу о максимальном числе из урока? Что происходит после одного раунда в
алгоритме подбора пар?)
 */
public class minAndMax {
}

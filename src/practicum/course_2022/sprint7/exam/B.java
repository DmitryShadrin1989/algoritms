package practicum.course_2022.sprint7.exam;
/*
B. Одинаковые суммы

На Алгосах устроили турнир по настольному теннису.
Гоша выиграл n партий, получив при этом некоторое количество очков за каждую из них.

Гоше стало интересно, можно ли разбить все заработанные им во время турнира очки на две части так,
чтобы сумма в них была одинаковой.

Формат ввода
В первой строке записано целое число n (0 ≤ n ≤ 300) –— количество выигранных партий.

Во второй строке через пробел записано n целых неотрицательных чисел,
каждое из которых не превосходит 300 –— заработанные в партиях очки.

Формат вывода
Нужно вывести True, если произвести такое разбиение возможно, иначе —– False

Пример 1
Ввод
4
1 5 7 1

Вывод
True

Пример 2
Ввод
3
2 10 9

Вывод
False
 */

/*
-- ПРИНЦИП РАБОТЫ --
Исходя из условия задача сводится к тому, что нужно дать ответ на вопрос -
можем ли мы разделить все заработанные очки на две равные части?
Поэтому если сумма всех очков не делится на цело на 2, то можно сразу вернуть - False.
Если сумма очков четная, то нам необходимо попробовать набрать из очков разных партий половину суммы,
если это возможно, то ответ - True, если нет то ответ - False.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Сначала проверим делится ли сумма очков на цело на 2 - fullAmount % 2 != 0. Если да, то получим полусумму halfAmount = fullAmount / 2.
Далее создадим одномерный массив dp[] размером = halfAmount + 1 и заполним его,
он представляет собой аналог всех вариантов вместительности рюкзака, в нашем случае полусумм от 0 до halfAmount.
Если такая сумма возможна из каких либо комбинаций очков партий, то ставим 1.
Внешний цикл идет по партиям (не имеет значения с какой стороны обходим), а внутренний по полусуммам его мы заполняем с правого конца,
чтобы исключить заполнения разных полусумм массива dp одним и тем же значением партии.
Выполнив все проходы мы получим все варианты сумм которые из очков партий на отрезке от 0 до halfAmount.
Если dp[halfAmount] == 1, то возвращаем True.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Временная сложность для инициализации будет O(n), где n - это количество партий.
Временная сложность для заполнения одномерного массива dp будет O(n*h), где n - это количество партий, а h - это полусумма очков за все партии.
Общая временная сложность O(n + n*h) ~ O(n*h)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Пространственная сложность O(n + h), где n - это количество партий, а h - это полусумма очков за все партии.

Успешная посылка - https://contest.yandex.ru/contest/25597/run-report/84264264/
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class B {
    public static void main(String[] args) throws IOException {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
            int n = Integer.parseInt(reader.readLine());
            String[] s = reader.readLine().split(" ");
            int[] points = new int[n];
            int fullAmount = 0;
            for (int i = 0; i < n; i++) {
                int point = Integer.parseInt(s[i]);
                points[i] = point;
                fullAmount += point;
            }
            if (fullAmount % 2 != 0) {
                System.out.println("False");
                return;
            }

            int halfAmount = fullAmount / 2;
            int[] dp = new int[halfAmount + 1];
            dp[0] = 1;
            for (int point : points) {
                for (int i = halfAmount; i >= point; --i) {
                    if (dp[i - point] == 1) {
                        dp[i] = 1;
                    }
                }
            }
            if (dp[halfAmount] != 1) {
                System.out.println("False");
            } else {
                System.out.println("True");
            }
        }
    }
}
